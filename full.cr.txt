==================== 
FILE: projekt_db/data/data_editor.py 

# data/data_editor.py
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QTableWidget, QTableWidgetItem, QHBoxLayout, QPushButton, QMessageBox
)
from PyQt5.QtGui import QIcon
import pandas as pd
from data.data_loader import save_data_to_json
from utils.utils import parse_decimal_input

def safe_to_numeric(value):
    """Bezpieczna konwersja wartoœci na liczbê dziesiêtn¹."""
    try:
        value = parse_decimal_input(value)
        return pd.to_numeric(value)
    except ValueError:
        return value

DATA_FILE = 'Ubytki.xlsx'

class DataEditorDialog(QDialog):
    """Okno dialogowe do edycji danych treningowych."""
    def __init__(self, data, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Edycja Danych Treningowych")
        self.data = data.copy()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        # Tabela danych
        self.table = QTableWidget(len(self.data), len(self.data.columns))
        self.table.setHorizontalHeaderLabels(self.data.columns)

        for row, (_, row_data) in enumerate(self.data.iterrows()):
            for col, value in enumerate(row_data):
                self.table.setItem(row, col, QTableWidgetItem(str(value)))

        self.table.resizeColumnsToContents()

        total_column_width = sum(self.table.columnWidth(col) for col in range(self.table.columnCount()))
        total_column_width += self.table.verticalHeader().width() + 20

        row_height = self.table.rowHeight(0) if self.table.rowCount() > 0 else 30
        header_height = self.table.horizontalHeader().height()
        total_height = header_height + (row_height * 15) + 40

        self.resize(total_column_width, total_height)
        layout.addWidget(self.table)

        button_layout = QHBoxLayout()

        add_button = QPushButton("Dodaj Wiersz")
        add_button.setIcon(QIcon("resources/icons/add.png"))
        add_button.clicked.connect(self.add_row)
        button_layout.addWidget(add_button)

        remove_button = QPushButton("Usuñ Wiersz")
        remove_button.setIcon(QIcon("resources/icons/remove.png"))
        remove_button.clicked.connect(self.remove_row)
        button_layout.addWidget(remove_button)

        up_button = QPushButton("Góra")
        up_button.setIcon(QIcon("resources/icons/up.png"))
        up_button.clicked.connect(self.move_row_up)
        button_layout.addWidget(up_button)

        down_button = QPushButton("Dó³")
        down_button.setIcon(QIcon("resources/icons/down.png"))
        down_button.clicked.connect(self.move_row_down)
        button_layout.addWidget(down_button)

        save_button = QPushButton("Zapisz Zmiany")
        save_button.setIcon(QIcon("resources/icons/save.png"))
        save_button.clicked.connect(self.save_changes)
        button_layout.addWidget(save_button)

        layout.addLayout(button_layout)
        self.setLayout(layout)

    def add_row(self):
        row_count = self.table.rowCount()
        self.table.insertRow(row_count)

    def remove_row(self):
        selected_rows = set(idx.row() for idx in self.table.selectionModel().selectedIndexes())
        for row in sorted(selected_rows, reverse=True):
            self.table.removeRow(row)

    def move_row_up(self):
        current_row = self.table.currentRow()
        if current_row > 0:
            self.swap_rows(current_row, current_row - 1)
            self.table.selectRow(current_row - 1)

    def move_row_down(self):
        current_row = self.table.currentRow()
        if current_row < self.table.rowCount() - 1:
            self.swap_rows(current_row, current_row + 1)
            self.table.selectRow(current_row + 1)

    def swap_rows(self, row1, row2):
        for col in range(self.table.columnCount()):
            item1 = self.table.item(row1, col)
            item2 = self.table.item(row2, col)
            value1 = item1.text() if item1 else ""
            value2 = item2.text() if item2 else ""
            self.table.setItem(row1, col, QTableWidgetItem(value2))
            self.table.setItem(row2, col, QTableWidgetItem(value1))

    def save_changes(self):
        try:
            rows = self.table.rowCount()
            cols = self.table.columnCount()
            new_data = []

            for row in range(rows):
                row_data = []
                for col in range(cols):
                    item = self.table.item(row, col)
                    value = item.text() if item else ""
                    row_data.append(value)
                new_data.append(row_data)

            new_data = pd.DataFrame(new_data, columns=self.data.columns)
            new_data = new_data.apply(lambda x: x.map(safe_to_numeric))

            save_data_to_json(new_data)
            self.parent().data = new_data

            print(f"Model przekazany z obiektu nadrzêdnego: {getattr(self.parent(), 'model', None)}")
            if hasattr(self.parent(), "model") and self.parent().model is not None:
                self.parent().model.train_models(new_data, force_retrain=True)
                print("Model przetrenowano na nowych danych.")
            else:
                print("Nie znaleziono modelu w obiekcie nadrzêdnym.")

            QMessageBox.information(self, "Sukces", "Dane zapisano i modele przetrenowano.")
            self.accept()

        except Exception as e:
            QMessageBox.warning(self, "B³¹d", f"Nie uda³o siê zapisaæ danych: {e}")
 

==================== 
FILE: projekt_db/data/data_list.py 

# data/data_list.py
import os
import xml.etree.ElementTree as ET
import pandas as pd

MATERIAL_MAP = {
    'Al Mg 3': 'CZ',
    '1.4301': 'N',
    'By Steel': 'CZ'
}

def load_data_from_xml(folder_path):
    data = []
    xml_files = ['1.4301.xml', 'By Steel.xml', 'Al Mg 3.xml']
    for filename in xml_files:
        full_path = os.path.join(folder_path, filename)
        if os.path.exists(full_path):
            tree = ET.parse(full_path)
            root = tree.getroot()

            material_element = root.find('.//Material')
            if material_element is not None:
                original_material = material_element.attrib.get('Name', 'Unknown')
                material = MATERIAL_MAP.get(original_material, 'Unknown')
            else:
                material = 'Unknown'

            for data_table in material_element.findall('.//DataTable'):
                thickness = float(data_table.attrib.get('SheetThickness', '0'))
                v_width = float(data_table.attrib.get('DieOpeningWidth', '0'))

                dt_entries = data_table.find('.//DTEntries')
                if dt_entries is not None:
                    for dt_entry in dt_entries.findall('.//DTEntry'):
                        angle = float(dt_entry.attrib.get('BendAngle', '0'))
                        bd = float(dt_entry.attrib.get('DX', '0'))

                        data.append({
                            'Material': material,
                            'Grubosc': thickness,
                            'V': v_width,
                            'Kat': angle,
                            'BD': bd
                        })
        else:
            print(f"Plik {filename} nie istnieje w folderze {folder_path}.")
    df = pd.DataFrame(data)
    df = df.sort_values(['Grubosc', 'V', 'Kat']).reset_index(drop=True)

    df['BD'] = df.groupby(['Grubosc', 'V'])['BD'].apply(lambda group: group.interpolate()).reset_index(level=[0, 1], drop=True)

    return df
 

==================== 
FILE: projekt_db/data/data_loader.py 

# data/data_loader.py
import pandas as pd
import os
import json
from ui.matrix_config_editor import load_matrix_config
from dotenv import load_dotenv

# Pobierz œcie¿kê do pliku data.json z zmiennych œrodowiskowych lub u¿yj domyœlnej
DATA_FILE = os.getenv('DATA_FILE', 'default_data.json')
DATA_FILE_EXCEL = 'Ubytki.xlsx'
DATA_FILE_JSON = 'data.json'

def load_data():
    """Wczytuje dane z pliku JSON lub Excela."""
    if os.path.exists(DATA_FILE_JSON):
        # Wczytaj dane z JSON
        return load_data_from_json()
    elif os.path.exists(DATA_FILE_EXCEL):
        # Jeœli JSON nie istnieje, zaimportuj dane z Excela i zapisz do JSON
        data = import_data_from_excel(DATA_FILE_EXCEL)
        save_data_to_json(data)
        return data
    else:
        raise FileNotFoundError(f"Brak danych treningowych: {DATA_FILE_JSON} lub {DATA_FILE_EXCEL}.")

def load_data_from_json(file_path="data.json"):
    """Wczytuje dane treningowe z pliku JSON."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Plik {file_path} nie istnieje.")
    try:
        with open(file_path, "r") as file:
            data = json.load(file)
            print("Wczytane dane JSON:")
            print(data)
        return pd.DataFrame(data)
    except json.JSONDecodeError as e:
        raise ValueError(f"Nie uda³o siê wczytaæ danych JSON: {e}")

def save_data_to_json(data, file_path="data.json"):
    """Zapisuje dane treningowe do pliku JSON."""
    try:
        with open(file_path, "w") as file:
            json.dump(data.to_dict(orient="records"), file, indent=4)
            print(f"Dane zapisano do pliku JSON: {file_path}")
    except Exception as e:
        raise IOError(f"Nie uda³o siê zapisaæ danych do JSON: {e}")

def filter_matrix_widths(grubosc, widths):
    """Filtruje szerokoœci matryc na podstawie konfiguracji."""
    config = load_matrix_config()
    allowed_widths = config.get(str(grubosc), widths)
    return [float(w) for w in widths if float(w) in allowed_widths]

def import_data_from_excel(file_path="Ubytki.xlsx"):
    """Importuje dane treningowe z pliku Excel."""
    try:
        data = pd.read_excel(file_path, sheet_name="Sheet1")

        # Upewnij siê, ¿e kolumna 'Szerokoœc matrycy V' jest tekstowa
        if 'Szerokoœc matrycy V' in data.columns:
            data['Szerokoœc matrycy V'] = data['Szerokoœc matrycy V'].astype(str).str.extract("(\d+)").astype(float)

        # Przekszta³cenie danych na poprawny format
        data = data.rename(columns={
            "Gruboœæ": "Grubosc",
            "Szerokoœc matrycy V": "V",
            "k¹t": "Kat",
            "CZ": "BD_CZ",
            "N": "BD_N"
        })

        # Usuwanie wierszy z brakuj¹cymi wartoœciami
        data = data.dropna(subset=["Grubosc", "V", "Kat", "BD_CZ", "BD_N"])

        return data

    except Exception as e:
        raise IOError(f"Nie uda³o siê zaimportowaæ danych z pliku Excel: {e}")

def export_data_to_excel(data, file_path=DATA_FILE_EXCEL):
    """Eksportuje dane treningowe do pliku Excel."""
    try:
        data.to_excel(file_path, sheet_name="Sheet1", index=False)
    except Exception as e:
        raise IOError(f"Nie uda³o siê wyeksportowaæ danych do pliku Excel: {e}")
 

==================== 
FILE: projekt_db/models/bd_model.py 

# models/bd_model.py
import os
import pandas as pd
import joblib
from xgboost import XGBRegressor
import time

class BDModel:
    def __init__(self):
        self.model_CZ = None
        self.model_N = None
        self.model_path_CZ = "models/model_CZ_from_excel.joblib"
        self.model_path_N = "models/model_N_from_excel.joblib"

    def train_models(self, data, force_retrain=False):
        """Trenuje modele dla materia³ów CZ i N."""
        print("Rozpoczêcie procesu zarz¹dzania modelami.")
        print(f"Œcie¿ki zapisów: {self.model_path_CZ}, {self.model_path_N}")

        X = data[['Grubosc', 'V', 'Kat']]
        y_CZ = data['BD_CZ']
        y_N = data['BD_N']

        if not force_retrain and os.path.exists(self.model_path_CZ) and os.path.exists(self.model_path_N):
            try:
                print("Wczytywanie zapisanych modeli...")
                self.model_CZ = joblib.load(self.model_path_CZ)
                self.model_N = joblib.load(self.model_path_N)
                print(f"Data modyfikacji modelu CZ: {time.ctime(os.path.getmtime(self.model_path_CZ))}")
                print(f"Data modyfikacji modelu N: {time.ctime(os.path.getmtime(self.model_path_N))}")
                return
            except Exception as e:
                print(f"B³¹d podczas wczytywania modeli: {e}. Rozpoczêcie ponownego treningu.")

        print("Trening modeli...")
        self.model_CZ = XGBRegressor(n_estimators=200, max_depth=5, learning_rate=0.1)
        self.model_CZ.fit(X, y_CZ)

        self.model_N = XGBRegressor(n_estimators=200, max_depth=5, learning_rate=0.1)
        self.model_N.fit(X, y_N)

        try:
            if os.path.exists(self.model_path_CZ):
                os.remove(self.model_path_CZ)
            if os.path.exists(self.model_path_N):
                os.remove(self.model_path_N)
        except Exception as e:
            print(f"B³¹d podczas usuwania starych modeli: {e}")

        try:
            joblib.dump(self.model_CZ, self.model_path_CZ)
            print(f"Model CZ zapisano do: {os.path.abspath(self.model_path_CZ)}")
            print(f"Nowa data modyfikacji modelu CZ: {time.ctime(os.path.getmtime(self.model_path_CZ))}")

            joblib.dump(self.model_N, self.model_path_N)
            print(f"Model N zapisano do: {os.path.abspath(self.model_path_N)}")
            print(f"Nowa data modyfikacji modelu N: {time.ctime(os.path.getmtime(self.model_path_N))}")
        except Exception as e:
            print(f"B³¹d podczas zapisywania modeli: {e}")

        if not os.path.exists(self.model_path_CZ) or not os.path.exists(self.model_path_N):
            print("B³¹d: Modele nie zosta³y zapisane!")
        else:
            print("Modele zosta³y poprawnie zapisane.")

    def oblicz_bd(self, t, V, kat, material):
        """Oblicza BD na podstawie modelu."""
        model = self.model_CZ if material == "CZ" else self.model_N
        X_new = pd.DataFrame([[t, V, kat]], columns=['Grubosc', 'V', 'Kat'])
        print(f"Obliczenia dla: {X_new}")
        bd_value = model.predict(X_new)[0]
        print(f"Wynik BD: {bd_value}")
        return max(bd_value, 0.0)
 

==================== 
FILE: projekt_db/models/calculator.py 

# models/calculator.py
from PyQt5.QtWidgets import QTableWidgetItem
from PyQt5.QtCore import Qt

class BDUbytkiCalculator:
    def __init__(self, model):
        self.model = model

    def calculate(self, grubosc, V, material, table):
        """Oblicza ³¹czn¹ d³ugoœæ, ca³kowity ubytek materia³u i efektywn¹ d³ugoœæ."""
        total_length = 0.0
        total_bd = 0.0
        total_effective_length = 0.0

        for row in range(table.rowCount()):
            dlugosc_item = table.item(row, 0)
            kat_item = table.item(row, 1)

            if not dlugosc_item or not kat_item:
                raise ValueError(f"Puste pola w wierszu {row + 1}.")

            dlugosc = float(dlugosc_item.text())
            kat = float(kat_item.text())
            grubosc = float(grubosc)
            V = float(V.strip("[]"))

            if kat == 0:
                bd_value = 0.0
            else:
                bd_value = self.model.oblicz_bd(grubosc, V, kat, material)

            total_length += dlugosc
            total_bd += bd_value
            total_effective_length += max(dlugosc - bd_value, 0)

            bd_item = table.item(row, 2) or QTableWidgetItem()
            bd_item.setText(f"{bd_value:.2f}")
            bd_item.setFlags(Qt.ItemIsEnabled)
            table.setItem(row, 2, bd_item)

        return total_length, total_bd, total_effective_length
 

==================== 
FILE: projekt_db/ui/main_window.py 

# ui/main_window.py
from PyQt5.QtWidgets import (
    QMainWindow, QVBoxLayout, QLabel, QPushButton, QTableWidget,
    QTableWidgetItem, QMessageBox, QComboBox, QHBoxLayout, QWidget,
    QGraphicsView, QGraphicsScene, QFileDialog, QGraphicsLineItem, QAction
)
from PyQt5.QtCore import Qt, QPoint, QPointF, QRectF, QLineF
from PyQt5.QtGui import QPainter, QPen, QColor, QPainterPath
import ezdxf


class CustomGraphicsView(QGraphicsView):
    """QGraphicsView z manualnym panningiem i obs³ug¹ kursora:
       - Domyœlnie kursor to strza³ka (Qt.ArrowCursor)
       - Podczas przytrzymania lewego przycisku – kursor zmienia siê na r¹czkê (Qt.ClosedHandCursor)
       - Po puszczeniu – kursor wraca do strza³ki.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setRenderHint(QPainter.Antialiasing)
        # Wy³¹czamy automatyczny tryb dragowania – u¿ywamy w³asnego panningu
        self.setDragMode(QGraphicsView.NoDrag)
        self.setInteractive(True)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorViewCenter)
        self._mouse_pressed_position = QPoint()
        self._panStart = QPoint()
        self._isPanning = False
        self.padding = 500
        self.setCursor(Qt.ArrowCursor)
        self.main_window = None

    def set_scene_padding(self):
        if self.scene() is not None:
            original_rect = self.scene().itemsBoundingRect()
            padded_rect = original_rect.adjusted(-self.padding, -self.padding, self.padding, self.padding)
            self.scene().setSceneRect(padded_rect)

    def _distance_to_point(self, line: QLineF, point: QPointF) -> float:
        A = line.p1()
        B = line.p2()
        P = point
        AB = B - A
        AP = P - A
        ab2 = AB.x() ** 2 + AB.y() ** 2
        if ab2 == 0:
            return (AP.x() ** 2 + AP.y() ** 2) ** 0.5
        t = (AP.x() * AB.x() + AP.y() * AB.y()) / ab2
        if t < 0:
            closest = A
        elif t > 1:
            closest = B
        else:
            closest = QPointF(A.x() + t * AB.x(), A.y() + t * AB.y())
        dx = P.x() - closest.x()
        dy = P.y() - closest.y()
        return (dx * dx + dy * dy) ** 0.5

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._mouse_pressed_position = event.pos()
            self._panStart = event.pos()
            self._isPanning = True
            self.viewport().setCursor(Qt.ClosedHandCursor)
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._isPanning:
            # Obliczamy przesuniêcie delta w widoku i stosujemy translate() do GUW
            delta = event.pos() - self._panStart
            self._panStart = event.pos()
            self.translate(delta.x(), delta.y())
        if self.main_window is not None:
            scene_pos = self.mapToScene(event.pos())
            self.main_window.update_status_bar(scene_pos)
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.viewport().setCursor(Qt.ArrowCursor)
            if (event.pos() - self._mouse_pressed_position).manhattanLength() < 10:
                try:
                    pos = self.mapToScene(event.pos())
                    print("Mouse released at scene pos:", pos)
                    tolerance = 20.0
                    search_rect = QRectF(pos.x() - tolerance, pos.y() - tolerance, tolerance * 2, tolerance * 2)
                    items = self.scene().items(search_rect, Qt.IntersectsItemShape)
                    closest_item = None
                    closest_distance = tolerance
                    for item in items:
                        if isinstance(item, QGraphicsLineItem) and item.data(0) == "bending":
                            p1 = item.mapToScene(item.line().p1())
                            p2 = item.mapToScene(item.line().p2())
                            qline = QLineF(p1, p2)
                            distance = self._distance_to_point(qline, pos)
                            print("Found bending line with distance:", distance)
                            if distance < closest_distance:
                                closest_distance = distance
                                closest_item = item
                    if closest_item is not None:
                        p1 = closest_item.mapToScene(closest_item.line().p1())
                        p2 = closest_item.mapToScene(closest_item.line().p2())
                        qline = QLineF(p1, p2)
                        clicked_point = QPointF((qline.x1() + qline.x2()) / 2, (qline.y1() + qline.y2()) / 2)
                        print("Closest bending line found. Center at:", clicked_point)
                        if self.main_window:
                            self.main_window.handle_bending_line_click(closest_item, clicked_point)
                    else:
                        print("No bending line found within tolerance.")
                except Exception as e:
                    print("Exception in mouseReleaseEvent:", e)
            self._isPanning = False
        super().mouseReleaseEvent(event)

    def wheelEvent(self, event):
        zoom_in_factor = 1.1
        zoom_out_factor = 1 / zoom_in_factor
        if event.angleDelta().y() > 0:
            self.scale(zoom_in_factor, zoom_in_factor)
        else:
            self.scale(zoom_out_factor, zoom_out_factor)

    def drawForeground(self, painter, rect):
        # Resetujemy transformacjê, aby rysowaæ w uk³adzie widoku (viewport)
        painter.resetTransform()
        pen = QPen(QColor("red"))
        pen.setWidth(1)
        painter.setPen(pen)
        # Pobieramy wymiary widoku
        viewRect = self.viewport().rect()
        center = viewRect.center()

        self.centerX = center.x()
        self.centerY = center.y()


        # Rysujemy poziom¹ liniê od lewej do prawej krawêdzi widoku, przy sta³ej wspó³rzêdnej Y = center.y()
        painter.drawLine(viewRect.left(), center.y(), viewRect.right(), center.y())
        # Rysujemy pionow¹ liniê od góry do do³u widoku, przy sta³ej wspó³rzêdnej X = center.x()
        painter.drawLine(center.x(), viewRect.top(), center.x(), viewRect.bottom())
        print(f"Ycenter = {self.centerY}, Xcenter = {self.centerX}")


class MainWindow(QMainWindow):
    def __init__(self, data, model, matrix_config_editor, data_editor):
        super().__init__()
        self.setWindowTitle("Kalkulator Ubytku Materia³u BD")
        self.data = data
        self.model = model
        self.matrix_config_editor = matrix_config_editor
        self.data_editor = data_editor
        self.last_selected_x = None
        self.dxf_scene = QGraphicsScene()
        self.init_ui()
        self.create_menus()
        self.showMaximized()

    def init_ui(self):
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("X: 0.00, Y: 0.00")
        self.main_widget = QWidget()
        self.main_layout = QHBoxLayout()

        # Lewa sekcja – parametry i tabela segmentów
        left_widget = QWidget()
        left_layout = QVBoxLayout()
        params_layout = QHBoxLayout()
        self.grubosc_input = QComboBox()
        self.grubosc_input.currentIndexChanged.connect(self.update_v_input)
        params_layout.addWidget(QLabel("Gruboœæ [mm]:"))
        params_layout.addWidget(self.grubosc_input)
        self.V_input = QComboBox()
        params_layout.addWidget(QLabel("V [mm]:"))
        params_layout.addWidget(self.V_input)
        self.material_input = QComboBox()
        self.material_input.addItems(["CZ", "N"])
        params_layout.addWidget(QLabel("Materia³:"))
        params_layout.addWidget(self.material_input)
        left_layout.addLayout(params_layout)
        self.table = QTableWidget(0, 4)
        self.table.setHorizontalHeaderLabels(["D³ugoœæ [mm]", "K¹t giêcia [°]", "BD [mm]", ""])
        self.table.horizontalHeader().setStretchLastSection(False)
        self.table.setColumnWidth(3, 30)
        left_layout.addWidget(self.table)
        self.table.setRowCount(0)
        self.last_selected_x = None
        self.remove_all_plus_rows()
        self.ensure_plus_row()
        self.calculate_button = QPushButton("Oblicz £¹czn¹ D³ugoœæ")
        self.calculate_button.clicked.connect(self.calculate_total_bd)
        left_layout.addWidget(self.calculate_button)
        self.result_label = QLabel()
        self.result_label.setAlignment(Qt.AlignCenter)
        left_layout.addWidget(self.result_label)
        left_widget.setLayout(left_layout)
        left_widget.setFixedWidth(400)

        # Prawa sekcja – widok DXF
        right_widget = QWidget()
        right_layout = QVBoxLayout()
        load_dxf_button = QPushButton("Wczytaj Plik DXF")
        load_dxf_button.clicked.connect(self.load_dxf_file)
        right_layout.addWidget(load_dxf_button)
        self.dxf_view = CustomGraphicsView()
        self.dxf_view.setScene(self.dxf_scene)
        # Ustawiamy alignment na œrodek – GUW pocz¹tkowo wycentrowany
        self.dxf_view.setAlignment(Qt.AlignCenter)
        self.dxf_view.setDragMode(QGraphicsView.NoDrag)
        self.dxf_view.main_window = self
        right_layout.addWidget(self.dxf_view)
        right_widget.setLayout(right_layout)
        self.main_layout.addWidget(left_widget, stretch=1)
        self.main_layout.addWidget(right_widget, stretch=3)
        self.main_widget.setLayout(self.main_layout)
        self.setCentralWidget(self.main_widget)

    def create_menus(self):
        menubar = self.menuBar()
        konfiguracja_menu = menubar.addMenu("Konfiguracja")
        matrix_config_action = QAction("Konfiguracja matryc", self)
        matrix_config_action.triggered.connect(self.openMatrixConfigEditor)
        konfiguracja_menu.addAction(matrix_config_action)
        data_editor_action = QAction("Edycja danych treningowych", self)
        data_editor_action.triggered.connect(self.openDataEditor)
        konfiguracja_menu.addAction(data_editor_action)

    def openMatrixConfigEditor(self):
        self.matrix_config_editor.exec_()
        self.update_v_input()

    def openDataEditor(self):
        self.data_editor.exec_()

    def update_status_bar(self, pos: QPointF):
        msg = f"X: {pos.x():.2f}, Y: {pos.y():.2f}"
        self.status_bar.showMessage(msg)

    def remove_all_plus_rows(self):
        for row in range(self.table.rowCount() - 1, -1, -1):
            widget = self.table.cellWidget(row, 0)
            if widget is not None and getattr(widget, 'plus_row', False):
                self.table.removeRow(row)

    def ensure_plus_row(self):
        row_count = self.table.rowCount()
        if row_count > 0:
            widget = self.table.cellWidget(row_count - 1, 0)
            if widget is not None and getattr(widget, 'plus_row', False):
                return
        self.add_plus_row()

    def add_plus_row(self):
        row = self.table.rowCount()
        self.table.insertRow(row)
        plus_button = QPushButton("+")
        plus_button.setStyleSheet(
            "QPushButton { background-color: green; color: white; font-weight: bold; max-width: 30px; }")
        plus_button.plus_row = True
        plus_button.clicked.connect(self.add_segment_via_plus)
        self.table.setCellWidget(row, 0, plus_button)
        for col in range(1, 4):
            self.table.setItem(row, col, QTableWidgetItem(""))

    def add_segment_via_plus(self):
        self.remove_all_plus_rows()
        self.insert_segment_row(self.table.rowCount(), absolute_x=100.0)
        self.add_plus_row()
        self.recalc_segments()

    def insert_segment_row(self, row, absolute_x, default_angle=90, line_id=None):
        self.table.insertRow(row)
        dlugosc_item = QTableWidgetItem(f"{absolute_x:.2f}")
        dlugosc_item.setData(Qt.UserRole + 1, absolute_x)
        if line_id is not None:
            dlugosc_item.setData(Qt.UserRole, line_id)
        self.table.setItem(row, 0, dlugosc_item)
        kat_item = QTableWidgetItem(f"{default_angle}")
        self.table.setItem(row, 1, kat_item)
        bd_item = QTableWidgetItem("")
        bd_item.setFlags(Qt.ItemIsEnabled)
        self.table.setItem(row, 2, bd_item)
        remove_button = QPushButton("-")
        remove_button.setStyleSheet(
            "QPushButton { background-color: red; color: white; font-weight: bold; max-width: 30px; }")
        remove_button.clicked.connect(self.remove_segment_by_button)
        self.table.setCellWidget(row, 3, remove_button)

    def insert_segment_sorted(self, new_x, line_id):
        insertion_index = self.table.rowCount() - 1
        for row in range(self.table.rowCount() - 1):
            item = self.table.item(row, 0)
            if item is not None:
                existing_x = item.data(Qt.UserRole + 1)
                if existing_x is None:
                    existing_x = 0.0
                if new_x < existing_x:
                    insertion_index = row
                    break
        self.insert_segment_row(insertion_index, absolute_x=new_x, default_angle=90, line_id=line_id)
        self.recalc_segments()

    def recalc_segments(self):
        n = self.table.rowCount() - 1
        if n <= 0:
            return
        segments = []
        for row in range(self.table.rowCount() - 1):
            item = self.table.item(row, 0)
            if item is not None:
                absolute_x = item.data(Qt.UserRole + 1)
                segments.append((row, absolute_x))
        segments.sort(key=lambda x: x[1])
        prev_x = None
        for (row, absolute_x) in segments:
            if prev_x is None:
                segment_value = absolute_x
            else:
                segment_value = absolute_x - prev_x
            prev_x = absolute_x
            self.table.item(row, 0).setText(f"{segment_value:.2f}")

    def find_segment_row_by_line_id(self, line_id):
        for row in range(self.table.rowCount() - 1):
            item = self.table.item(row, 0)
            if item is not None and item.data(Qt.UserRole) == line_id:
                return row
        return None

    def remove_segment_by_button(self):
        button = self.sender()
        if button:
            for row in range(self.table.rowCount()):
                widget = self.table.cellWidget(row, 3)
                if widget is button:
                    item = self.table.item(row, 0)
                    if item is not None:
                        line_id = item.data(Qt.UserRole)
                        if line_id is not None:
                            for scene_item in list(self.dxf_scene.items()):
                                if (isinstance(scene_item, QGraphicsLineItem) and
                                        scene_item.data(1) == "selected" and
                                        id(scene_item) == line_id):
                                    pen = QPen(QColor("yellow"))
                                    scene_item.setPen(pen)
                                    scene_item.setData(1, None)
                                    print("Minus clicked: Unselected bending line with id", line_id)
                                    break
                    self.table.removeRow(row)
                    break
        if self.table.rowCount() == 0:
            self.add_plus_row()
        else:
            self.recalc_segments()

    def load_dxf_file(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Wybierz Plik DXF", "", "Pliki DXF (*.dxf)")
        if not file_path:
            return
        try:
            self.table.setRowCount(0)
            self.last_selected_x = None
            self.remove_all_plus_rows()
            self.ensure_plus_row()
            doc = ezdxf.readfile(file_path)
            self.dxf_scene.clear()
            for entity in doc.modelspace():
                if entity.dxftype() == 'LINE':
                    start = entity.dxf.start
                    end = entity.dxf.end
                    if hasattr(entity.dxf, 'color') and entity.dxf.color == 2:
                        pen = QPen(QColor("yellow"))
                        bending_line = QGraphicsLineItem(start.x, start.y, end.x, end.y)
                        bending_line.setPen(pen)
                        bending_line.setData(0, "bending")
                        self.dxf_scene.addItem(bending_line)
                    else:
                        self.dxf_scene.addLine(start.x, start.y, end.x, end.y)
                elif entity.dxftype() == 'CIRCLE':
                    center = entity.dxf.center
                    radius = entity.dxf.radius
                    self.dxf_scene.addEllipse(center.x - radius, center.y - radius, 2 * radius, 2 * radius)
                elif entity.dxftype() == 'ARC':
                    center = entity.dxf.center
                    radius = entity.dxf.radius
                    start_angle = entity.dxf.start_angle
                    end_angle = entity.dxf.end_angle
                    rect = QRectF(center.x - radius, center.y - radius, 2 * radius, 2 * radius)
                    path = QPainterPath()
                    path.arcMoveTo(rect, start_angle)
                    path.arcTo(rect, start_angle, (end_angle - start_angle))
                    self.dxf_scene.addPath(path)
                elif entity.dxftype() == 'POLYLINE':
                    points = list(entity.points())
                    for i in range(len(points) - 1):
                        self.dxf_scene.addLine(points[i][0], points[i][1],
                                               points[i + 1][0], points[i + 1][1])
                elif entity.dxftype() == 'LWPOLYLINE':
                    points = list(entity.points())
                    for i in range(len(points)):
                        start_point = points[i]
                        end_point = points[(i + 1) % len(points)]
                        bulge = start_point[4] if len(start_point) > 4 else 0
                        if bulge == 0:
                            self.dxf_scene.addLine(start_point[0], start_point[1],
                                                   end_point[0], end_point[1])
                        else:
                            self.draw_bulge_arc(start_point, end_point, bulge)
                else:
                    print(f"Nieobs³ugiwany typ: {entity.dxftype()}")
            # Ustalamy LUW: przesuwamy elementy sceny, aby lewy dolny róg geometrii (LUW) by³ w (0,0)
            self.adjust_scene_origin()
            # GUW: Reset transformacji, odwrócenie osi Y, wycentrowanie rysunku
            self.dxf_view.resetTransform()
            self.dxf_view.scale(1, -1)
            self.center_dxf_in_view()
        except Exception as e:
            QMessageBox.warning(self, "B³¹d", f"Nie uda³o siê wczytaæ pliku DXF:\n{e}")

    def draw_bulge_arc(self, start_point, end_point, bulge):
        import math
        chord_length = math.sqrt((end_point[0] - start_point[0]) ** 2 + (end_point[1] - start_point[1]) ** 2)
        radius = abs(chord_length / (2 * math.sin(2 * math.atan(bulge))))
        center_x = (start_point[0] + end_point[0]) / 2
        center_y = (start_point[1] + end_point[1]) / 2
        angle_start = math.degrees(math.atan2(start_point[1] - center_y, start_point[0] - center_x))
        angle_end = math.degrees(math.atan2(end_point[1] - center_y, end_point[0] - center_x))
        rect = QRectF(center_x - radius, -center_y - radius, 2 * radius, 2 * radius)
        path = QPainterPath()
        path.arcMoveTo(rect, angle_start)
        path.arcTo(rect, angle_start, angle_end - angle_start)
        self.dxf_scene.addPath(path)

    def adjust_scene_origin(self):
        """Przesuwa rysunek tak, aby LUW mia³o (0,0) w lewym dolnym rogu geometrii.
           Dla rysunków AutoCada przyjmujemy:
             min_x = bounding_rect.left()
             min_y = bounding_rect.top()
        """
        bounding_rect = self.dxf_scene.itemsBoundingRect()
        print("Before adjust_scene_origin, bounding_rect:", bounding_rect)
        min_x = bounding_rect.left()
        min_y = bounding_rect.top()
        dx = -min_x
        dy = -min_y
        print(f"dx={dx}, dy= {dy}")
        print(f"Przesuwam rysunek o dx={dx}, dy={dy}, aby LUW (0,0) by³ w lewym dolnym rogu.")
        for item in list(self.dxf_scene.items()):
            # item.moveBy(dx, dy)
            item.moveBy(dx, dy)
        new_rect = self.dxf_scene.itemsBoundingRect()

        # Dodajemy margines, aby scena by³a wiêksza ni¿ sama geometria rysunku –
        # to umo¿liwi panning nawet, gdy rysunek mieœci siê w oknie.
        margin = 5000  # Mo¿esz dostosowaæ tê wartoœæ
        new_rect = new_rect.adjusted(-margin, -margin, margin, margin)

        self.dxf_scene.setSceneRect(new_rect)
        print("After adjust_scene_origin, sceneRect:", self.dxf_scene.sceneRect())


    def center_dxf_in_view(self):
        """GUW: Centruje rysunek (bez modyfikacji LUW) przy pomocy transformacji widoku.
           Oblicza przesuniêcie miêdzy œrodkiem sceny a œrodkiem widoku i stosuje translate().
        """
        # Reset transformacji, zachowuj¹c ustawienie LUW (transformacja LUW pozostaje)
        self.dxf_view.resetTransform()
        # Najpierw odwracamy oœ Y, aby wspó³rzêdne rosnê³y w górê
        self.dxf_view.scale(1, -1)
        # Obliczamy œrodek widoku (w punktach widoku) i przeliczamy na wspó³rzêdne sceny
        view_center = self.dxf_view.mapToScene(self.dxf_view.viewport().rect().center())
        scene_center = self.dxf_scene.sceneRect().center()
        offset = scene_center - view_center
        self.dxf_view.translate(offset.x(), offset.y())

    def handle_bending_line_click(self, item, clicked_point):
        new_line_x = clicked_point.x()
        print("handle_bending_line_click - clicked_point:", clicked_point)
        if item.data(1) == "selected":
            row_index = self.find_segment_row_by_line_id(id(item))
            if row_index is not None:
                self.table.removeRow(row_index)
            item.setData(1, None)
            pen = QPen(QColor("yellow"))
            item.setPen(pen)
            self.recalc_segments()
            print("Unselected bending line. Segment removed.")
            return
        print("Selecting bending line with x =", new_line_x)
        item.setData(1, "selected")
        pen = QPen(QColor("magenta"))
        pen.setWidth(2)
        item.setPen(pen)
        self.insert_segment_sorted(new_line_x, line_id=id(item))
        print("Selected bending line. New segment inserted.")

    def update_v_input(self):
        selected_grubosc = self.grubosc_input.currentText()
        if self.data is not None:
            try:
                V_values = sorted(set(self.data.loc[self.data['Grubosc'] == float(selected_grubosc), 'V']))
            except ValueError:
                V_values = []
            self.V_input.clear()
            self.V_input.addItems([str(x) for x in V_values])

    def recalc_segments(self):
        n = self.table.rowCount() - 1
        if n <= 0:
            return
        segments = []
        for row in range(self.table.rowCount() - 1):
            item = self.table.item(row, 0)
            if item is not None:
                absolute_x = item.data(Qt.UserRole + 1)
                segments.append((row, absolute_x))
        segments.sort(key=lambda x: x[1])
        prev_x = None
        for (row, absolute_x) in segments:
            if prev_x is None:
                segment_value = absolute_x
            else:
                segment_value = absolute_x - prev_x
            prev_x = absolute_x
            self.table.item(row, 0).setText(f"{segment_value:.2f}")

    def find_segment_row_by_line_id(self, line_id):
        for row in range(self.table.rowCount() - 1):
            item = self.table.item(row, 0)
            if item is not None and item.data(Qt.UserRole) == line_id:
                return row
        return None

    def remove_segment_by_button(self):
        button = self.sender()
        if button:
            for row in range(self.table.rowCount()):
                widget = self.table.cellWidget(row, 3)
                if widget is button:
                    item = self.table.item(row, 0)
                    if item is not None:
                        line_id = item.data(Qt.UserRole)
                        if line_id is not None:
                            for scene_item in list(self.dxf_scene.items()):
                                if (isinstance(scene_item, QGraphicsLineItem) and
                                        scene_item.data(1) == "selected" and
                                        id(scene_item) == line_id):
                                    pen = QPen(QColor("yellow"))
                                    scene_item.setPen(pen)
                                    scene_item.setData(1, None)
                                    print("Minus clicked: Unselected bending line with id", line_id)
                                    break
                    self.table.removeRow(row)
                    break
        if self.table.rowCount() == 0:
            self.add_plus_row()
        else:
            self.recalc_segments()

    def insert_segment_sorted(self, new_x, line_id):
        insertion_index = self.table.rowCount() - 1
        for row in range(self.table.rowCount() - 1):
            item = self.table.item(row, 0)
            if item is not None:
                existing_x = item.data(Qt.UserRole + 1)
                if existing_x is None:
                    existing_x = 0.0
                if new_x < existing_x:
                    insertion_index = row
                    break
        self.insert_segment_row(insertion_index, absolute_x=new_x, default_angle=90, line_id=line_id)
        self.recalc_segments()

    def add_segment_via_plus_with_defaults(self, default_length=100, default_angle=90, line_id=None):
        self.remove_all_plus_rows()
        plus_row_index = self.table.rowCount()
        self.insert_segment_row(plus_row_index, absolute_x=default_length, default_angle=default_angle, line_id=line_id)
        self.add_plus_row()
        self.recalc_segments()

    def calculate_total_bd(self):
        try:
            material = self.material_input.currentText()
            total_length = 0.0
            total_bd = 0.0
            for row in range(self.table.rowCount() - 1):
                dlugosc_item = self.table.item(row, 0)
                kat_item = self.table.item(row, 1)
                if not dlugosc_item or not kat_item:
                    continue
                dlugosc = float(dlugosc_item.text())
                kat = float(kat_item.text())
                grubosc = float(self.grubosc_input.currentText())
                V = float(self.V_input.currentText())
                bd_value = 0.0 if kat == 0 else self.model.oblicz_bd(grubosc, V, kat, material)
                total_length += dlugosc
                total_bd += bd_value
                bd_item = QTableWidgetItem(f"{bd_value:.2f}")
                bd_item.setFlags(Qt.ItemIsEnabled)
                self.table.setItem(row, 2, bd_item)
            self.result_label.setText(
                f"£¹czna D³ugoœæ: {total_length:.2f} mm\n£¹czny Ubytek (BD): {total_bd:.2f} mm"
            )
        except Exception as e:
            QMessageBox.warning(self, "B³¹d", f"Wyst¹pi³ b³¹d podczas obliczania BD:\n{e}")

    def populate_comboboxes(self):
        if self.data is not None:
            grubosc_values = sorted(self.data['Grubosc'].unique())
            self.grubosc_input.clear()
            self.grubosc_input.addItems([str(x) for x in grubosc_values])
            if grubosc_values:
                self.update_v_input()


## jest ok
 

==================== 
FILE: projekt_db/ui/matrix_config_editor.py 

# ui/matrix_config_editor.py
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTableWidget, QTableWidgetItem, QPushButton, QMessageBox
from PyQt5.QtCore import Qt
import json
import os

CONFIG_FILE = "config/matrix_config.json"

def load_matrix_config():
    """Wczytuje konfiguracjê matryc z pliku JSON."""
    try:
        with open(CONFIG_FILE, "r") as file:
            return json.load(file)
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError as e:
        print(f"B³¹d wczytywania konfiguracji matryc: {e}")
        return {}

def save_matrix_config(config):
    """Zapisuje konfiguracjê matryc do pliku JSON."""
    try:
        with open(CONFIG_FILE, "w") as file:
            json.dump(config, file, indent=4)
            print(f"Zapisano konfiguracjê matryc w {CONFIG_FILE}")
    except Exception as e:
        print(f"B³¹d zapisu konfiguracji matryc: {e}")

class MatrixConfigEditor(QDialog):
    """Okno przypisywania matryc do gruboœci materia³u."""
    def __init__(self, grubosci, matryce, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Przypisz Matryce")
        self.grubosci = grubosci
        self.matryce = matryce
        self.config = load_matrix_config()
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        self.table = QTableWidget(len(self.grubosci), len(self.matryce))
        self.table.setHorizontalHeaderLabels([str(m) for m in self.matryce])
        self.table.setVerticalHeaderLabels([str(g) for g in self.grubosci])

        for row, grubosc in enumerate(self.grubosci):
            for col, matryca in enumerate(self.matryce):
                item = QTableWidgetItem()
                item.setCheckState(Qt.Checked if str(grubosc) in self.config and matryca in self.config[str(grubosc)] else Qt.Unchecked)
                self.table.setItem(row, col, item)

        self.table.resizeColumnsToContents()

        total_column_width = sum(self.table.columnWidth(col) for col in range(self.table.columnCount()))
        total_column_width += self.table.verticalHeader().width() + 40

        row_height = self.table.rowHeight(0) if self.table.rowCount() > 0 else 30
        header_height = self.table.horizontalHeader().height()
        total_height = header_height + (row_height * len(self.grubosci)) + 60

        self.resize(total_column_width, total_height)
        layout.addWidget(self.table)

        save_button = QPushButton("Zapisz")
        save_button.clicked.connect(self.save_config)
        layout.addWidget(save_button)

        self.setLayout(layout)

    def save_config(self):
        """Zapisuje now¹ konfiguracjê."""
        new_config = {}
        for row, grubosc in enumerate(self.grubosci):
            selected_matryce = []
            for col, matryca in enumerate(self.matryce):
                item = self.table.item(row, col)
                if item and item.checkState() == Qt.Checked:
                    selected_matryce.append(matryca)
            new_config[str(grubosc)] = selected_matryce

        save_matrix_config(new_config)
        QMessageBox.information(self, "Sukces", "Konfiguracja matryc zosta³a zapisana.")
        self.accept()
 

==================== 
FILE: projekt_db/ui/parameter_manager.py 

# ui/parameter_manager.py
from PyQt5.QtWidgets import QVBoxLayout, QLabel, QComboBox, QHBoxLayout
from ui.matrix_config_editor import load_matrix_config

class ParameterManager:
    def __init__(self, parent):
        self.parent = parent
        self.layout = QHBoxLayout()

        self.grubosc_input = QComboBox()
        self.grubosc_input.currentIndexChanged.connect(self.update_v_input)
        self.layout.addWidget(QLabel("Gruboœæ [mm]:"))
        self.layout.addWidget(self.grubosc_input)

        self.V_input = QComboBox()
        self.layout.addWidget(QLabel("V [mm]:"))
        self.layout.addWidget(self.V_input)

        self.material_input = QComboBox()
        self.material_input.addItems(["CZ", "N"])
        self.layout.addWidget(QLabel("Materia³:"))
        self.layout.addWidget(self.material_input)

    def populate_comboboxes(self, data):
        """Wype³nia listy rozwijalne na podstawie danych."""
        grubosc_values = sorted(data['Grubosc'].unique())
        self.grubosc_input.addItems([str(x) for x in grubosc_values])

    def update_v_input(self):
        """Aktualizuje listê V na podstawie wybranej gruboœci."""
        selected_grubosc = self.grubosc_input.currentText()
        config = load_matrix_config()
        self.V_input.clear()
        if selected_grubosc in config:
            self.V_input.addItems([str(x) for x in config[selected_grubosc]])

    def get_selected_parameters(self):
        """Zwraca wybrane parametry."""
        return {
            "grubosc": self.grubosc_input.currentText(),
            "V": self.V_input.currentText(),
            "material": self.material_input.currentText(),
        }
 

==================== 
FILE: projekt_db/ui/segment_manager.py 

# ui/segment_manager.py
from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem
from PyQt5.QtCore import Qt

class SegmentManager:
    def __init__(self, parent):
        self.parent = parent
        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["D³ugoœæ [mm]", "K¹t giêcia [°]", "BD [mm]"])

    def calculate_total_bd(self, params, model):
        """Oblicza ca³kowity ubytek materia³u."""
        total_length, total_bd = 0.0, 0.0

        for row in range(self.table.rowCount()):
            length_item = self.table.item(row, 0)
            angle_item = self.table.item(row, 1)

            if not length_item or not angle_item:
                continue

            length = float(length_item.text())
            angle = float(angle_item.text())
            bd = model.oblicz_bd(float(params["grubosc"]), float(params["V"]), angle, params["material"])

            total_length += length
            total_bd += bd

            bd_item = QTableWidgetItem(f"{bd:.2f}")
            bd_item.setFlags(Qt.ItemIsEnabled)
            self.table.setItem(row, 2, bd_item)

        return f"£¹czna d³ugoœæ: {total_length} mm\nUbytek: {total_bd} mm"
 

==================== 
FILE: projekt_db/utils/utils.py 

# utils/utils.py
def parse_decimal_input(value):
    """Konwertuje wartoœæ tekstow¹ z przecinkiem lub kropk¹ na liczbê dziesiêtn¹."""
    try:
        return float(value.replace(',', '.'))
    except ValueError:
        raise ValueError(f"Niepoprawny format liczbowy: {value}")
 

==================== 
FILE: projekt_db/main.py 

# main.py
from PyQt5.QtWidgets import QApplication
from data.data_loader import load_data
from models.bd_model import BDModel
from ui.main_window import MainWindow
from ui.matrix_config_editor import MatrixConfigEditor
from data.data_editor import DataEditorDialog

if __name__ == "__main__":
    app = QApplication([])

    # Inicjalizacja modelu
    model = BDModel()

    # Wczytanie danych
    data = load_data()

    # Próba wczytania lub przetrenowania modeli
    print("Próba wczytania istniej¹cych modeli...")
    model.train_models(data, force_retrain=False)

    # Przygotowanie konfiguratora matryc
    grubosci = sorted(data['Grubosc'].unique())
    matryce = sorted(set(data['V'].unique()))
    matrix_config_editor = MatrixConfigEditor(grubosci, matryce)

    # Inicjalizacja edytora danych
    data_editor = DataEditorDialog(data)

    # Utworzenie g³ównego okna aplikacji
    window = MainWindow(data, model, matrix_config_editor, data_editor)
    window.populate_comboboxes()
    window.show()

    app.exec_()
 

